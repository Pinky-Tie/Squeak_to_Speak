from pydantic import BaseModel, ValidationError
# User Story: I want the chatbot to provide contact information for relevant hotlines to quickly access support during emergencies or non-urgent situations.

# Chain 1
# Goal: Identify userâ€™s preferences for a hotline
# Implementation: This chain retrieves relevant data from the user input and all relevant information from the database. Creating a Pydantic model instance containing all information. At the end, the chain returns the information in a string format.
class HotlinePreferencesModel(BaseModel):
    specialty: str
    location: str
    always_open: bool = None

class IdentifyHotlinePreferences:
    def process_input(self, user_input: dict):
        """Process user input to extract preferences for a hotline."""
        try:
            preferences = HotlinePreferencesModel(**user_input)
            return preferences
        except ValidationError as e:
            return {"error": str(e)}


# Chain 2
# Goal: Identify the best hotline
# Implementation: This chain processes the user preferences generated by the previous chain, queries the database for the most relevant entries, and retrieves the best matches.
class HotlineFinder:
    def __init__(self, db_manager):
        self.db_manager = db_manager

    def find_best_match(self, preferences):
        """Query the database for the best hotline matches based on user preferences."""
        query = """
        SELECT * FROM Help_lines
        WHERE country = :location
          AND (specialty LIKE :specialty OR :specialty IS NULL)
          AND (always_open = :always_open OR :always_open IS NULL)
        ORDER BY always_open DESC
        LIMIT 1
        """
        params = {
            "location": preferences.location,
            "specialty": f"%{preferences.specialty}%",
            "always_open": preferences.always_open,
        }
        results = self.db_manager.select(query, params)
        return results


# Chain 3
# Goal: Output the best hotline
# Implementation: This chain receives both inputs (user input and best hotline match) and generates a final output using a prompt template.
class HotlineOutputFormatter:
    def format_output(self, hotline, user_input):
        """Generate a formatted response for the user."""
        if hotline:
            line = hotline[0]  # Assume result is a list of dicts/rows
            return (
                f"We recommend the '{line['name']}' hotline for {user_input['specialty']} support.\n"
                f"Details:\n"
                f"- Type: {line['TYPE']}\n"
                f"- Phone: {line['phone']}\n"
                f"- Email: {line['email']}\n"
                f"- Website: {line['website']}\n"
                f"- Organization: {line['Organization']}\n"
                f"- Always Open: {'Yes' if line['always_open'] else 'No'}"
            )
        return "We couldn't find any suitable hotlines based on your preferences."
